<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"><channel><title>Tom Dalling</title><link>http://www.tomdalling.com/?utm_source=rss&amp;utm_medium=rss</link><atom:link href="http://www.tomdalling.com/blog/category/software-design/feed/" rel="self" type="application/rss+xml"></atom:link><description>Web &amp; software developer</description><language>en</language><generator>Tom Dalling's fingertips</generator><sy:updatePeriod>daily</sy:updatePeriod><sy:updateFrequency>1</sy:updateFrequency><item><title>Why NSOrderedSet Doesn't Inherit From NSSet - A Real‑life Example of the Liskov Substitution Principle</title><link>http://www.tomdalling.com/blog/software-design/why-nsorderedset-doesnt-inherit-from-nsset-a-real‑life-example-of-the-liskov-substitution-principle/?utm_source=rss&amp;utm_medium=rss</link><description><![CDATA[<p>There was an interesting question on StackOverflow this morning: <a href="http://stackoverflow.com/questions/11278995/why-doesnt-nsorderedset-inherit-from-nsset">Why doesn't NSOrderedSet inherit from NSSet?</a> It's interesting because the reason is so easy to miss. I thought it would make a good blog post because it turned out to be a nice, real-life example of the <a href="http://tomdalling.com/blog/software-design/solid-class-design-the-liskov-substitution-principle">Liskov substitution principle</a> (herein abbreviated to LSP).</p>
]]></description><pubDate>Sun, 01 Jul 2012 00:00:00 +0000</pubDate><category><![CDATA[Software Design]]></category><guid isPermaLink="false">627 http://tomdalling.com/blog/?p=627</guid></item><item><title>Resource Acquisition is Initialisation (RAII) Explained</title><link>http://www.tomdalling.com/blog/software-design/resource-acquisition-is-initialisation-raii-explained/?utm_source=rss&amp;utm_medium=rss</link><description><![CDATA[<p>In the competition to make the worst acronym, <a href="http://en.wikipedia.org/wiki/RAII">RAII</a> probably comes second after <a href="http://en.wikipedia.org/wiki/HATEOAS">HATEOS</a>. Nevertheless, it is an important concept because it allows you to write safer code in C++ — a harsh, unforgiving language that is all too happy to help you shoot yourself in the foot.</p><p>This article will explain exception-safety and common pitfalls in C++. As we work out how to avoid these problems, we will accidentally discover RAII. Then, we will finish by defining exactly was RAII is, and where it is already being used.</p>
]]></description><pubDate>Thu, 17 May 2012 00:00:00 +0000</pubDate><category><![CDATA[Software Design]]></category><guid isPermaLink="false">586 http://tomdalling.com/blog/?p=586</guid></item><item><title>SOLID Class Design: The Interface Segregation Principle</title><link>http://www.tomdalling.com/blog/software-design/solid-class-design-the-interface-segregation-principle/?utm_source=rss&amp;utm_medium=rss</link><description><![CDATA[<p>This is that last part of a five part series about <a title="Principles of OOD" href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod">SOLID class design principles</a> by <a href="http://www.objectmentor.com/omTeam/martin_r.html">Robert C. Martin</a>. The SOLID principles focus on achieving code that is maintainable, robust, and reusable. In this post, I will discuss the Interface Segregation Principle.</p>
<blockquote><p><strong>The Interface Segregation Principle (ISP)</strong>: <em>Clients should not be forced to depend upon interfaces that they do not use</em>.</p>
</blockquote>
]]></description><pubDate>Thu, 18 Feb 2010 00:00:00 +0000</pubDate><category><![CDATA[Software Design]]></category><guid isPermaLink="false">352 http://tomdalling.com/?p=352</guid></item><item><title>SOLID Class Design: The Dependency Inversion Principle</title><link>http://www.tomdalling.com/blog/software-design/solid-class-design-the-dependency-inversion-principle/?utm_source=rss&amp;utm_medium=rss</link><description><![CDATA[<p>This is part four of a five part series about <a title="Principles of OOD" href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod">SOLID class design principles</a> by <a href="http://www.objectmentor.com/omTeam/martin_r.html">Robert C. Martin</a>. The SOLID principles focus on achieving code that is maintainable, robust, and reusable. In this post, I will discuss the Dependency Inversion Principle.</p>
<blockquote><p><strong>The Dependency Inversion Principle (DIP)</strong>: <em>High level modules should not depend upon low level modules. Both should depend upon abstractions</em>.</p>
</blockquote>
]]></description><pubDate>Sat, 19 Dec 2009 00:00:00 +0000</pubDate><category><![CDATA[Software Design]]></category><guid isPermaLink="false">307 http://tomdalling.com/?p=307</guid></item><item><title>SOLID Class Design: The Liskov Substitution Principle</title><link>http://www.tomdalling.com/blog/software-design/solid-class-design-the-liskov-substitution-principle/?utm_source=rss&amp;utm_medium=rss</link><description><![CDATA[<p>This is part three of a five part series about <a title="Principles of OOD" href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod">SOLID class design principles</a> by <a href="http://www.objectmentor.com/omTeam/martin_r.html">Robert C. Martin</a>. The SOLID principles focus on achieving code that is maintainable, robust, and reusable. In this post, I will discuss the Liskov Substitution Principle.</p>
<blockquote><p><strong>The Liskov Substitution Principle (LSP)</strong>: <em>functions that use pointers to base classes must be able to use objects of derived classes without knowing it</em>.</p>
</blockquote>
]]></description><pubDate>Sat, 21 Nov 2009 00:00:00 +0000</pubDate><category><![CDATA[Software Design]]></category><guid isPermaLink="false">267 http://tomdalling.com/?p=267</guid></item><item><title>SOLID Class Design: The Open Closed Principle</title><link>http://www.tomdalling.com/blog/software-design/solid-class-design-the-open-closed-principle/?utm_source=rss&amp;utm_medium=rss</link><description><![CDATA[<p>This is part two of a five part series about <a title="Principles of OOD" href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod">SOLID class design principles</a> by <a href="http://www.objectmentor.com/omTeam/martin_r.html">Robert C. Martin</a>. The SOLID principles focus on achieving code that is maintainable, robust, and reusable. In this post, I will discuss the Open Closed Principle.</p>
<blockquote><p><strong>The Open Closed Principle (OCP)</strong>: <em>You should be able to extend a classes behavior, without modifying it</em>.</p>
</blockquote>
]]></description><pubDate>Sat, 14 Nov 2009 00:00:00 +0000</pubDate><category><![CDATA[Software Design]]></category><guid isPermaLink="false">245 http://tomdalling.com/?p=245</guid></item><item><title>SOLID Class Design: The Single Responsibility Principle</title><link>http://www.tomdalling.com/blog/software-design/solid-class-design-the-single-responsibility-principle/?utm_source=rss&amp;utm_medium=rss</link><description><![CDATA[<p>This is part one of a five part series about <a title="The Principles of OOD" href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod">SOLID class design principles</a> by <a href="http://www.objectmentor.com/omTeam/martin_r.html">Robert C. Martin</a>. The SOLID principles focus on achieving code that is maintainable, robust, and reusable. In this post, I will discuss the Single Responsibility Principle.</p>
<blockquote><p><strong>The Single Responsibility Principle (SRP)</strong>: <em>A class should have one, and only one, reason to change</em>.</p>
</blockquote>
]]></description><pubDate>Thu, 12 Nov 2009 00:00:00 +0000</pubDate><category><![CDATA[Software Design]]></category><guid isPermaLink="false">232 http://tomdalling.com/?p=232</guid></item><item><title>Model View Controller Explained</title><link>http://www.tomdalling.com/blog/software-design/model-view-controller-explained/?utm_source=rss&amp;utm_medium=rss</link><description><![CDATA[<p>Model view controller (MVC) is a very useful and popular design pattern. If you're writing software, you should know it. Unfortunately it's also one of the hardest to truly understand. In this article I will provide what I think is the simplest explanation of MVC, and why you should use it.</p>
]]></description><pubDate>Sun, 31 May 2009 00:00:00 +0000</pubDate><category><![CDATA[Software Design]]></category><guid isPermaLink="false">3 http://tomdalling.com/?p=3</guid></item></channel></rss>
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta content="IE=edge" http-equiv="X-UA-Compatible" />
    <meta content="width=device-width, initial-scale=1" name="viewport" />
    <title>Modern OpenGL 08 – Even More Lighting: Directional Lights, Spotlights, &amp; Multiple Lights — Tom Dalling</title>
    <link href="/style.css" rel="stylesheet" />
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" />
    <link type="text/css" rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro" />
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  <link rel="canonical" href="/blog/modern-opengl/08-even-more-lighting-directional-lights-spotlights-multiple-lights/" /></head>

  <body>

    <div class="container">

      <div class="row">
        <div class="col-md-12">
          <nav role="navigation" class="navbar navbar-default">
            <div class="container-fluid">
              <div class="navbar-header">
                <button data-target="#bs-example-navbar-collapse-1" data-toggle="collapse" class="navbar-toggle" type="button">
                  <span class="sr-only">Toggle navigation</span>
                  <span class="icon-bar"></span>
                  <span class="icon-bar"></span>
                  <span class="icon-bar"></span>
                </button>
                <a href="/" class="navbar-brand">Tom Dalling</a>
              </div>

              <div id="bs-example-navbar-collapse-1" class="collapse navbar-collapse">
                <ul class="nav navbar-nav">
                  <li><a href="/">Home</a></li>
                  <li><a href="/blog/">Blog</a></li>
                </ul>
              </div>
            </div>
          </nav>
        </div>
      </div>

      <div class="row">

        <main class="col-md-8"><article class="post post-single">

  <header>
    <h1><a href="/blog/modern-opengl/08-even-more-lighting-directional-lights-spotlights-multiple-lights/">Modern OpenGL 08 – Even More Lighting: Directional Lights, Spotlights, &amp; Multiple Lights</a></h1>
    <small class="meta">
      <span class="post-date">01 Nov, 2014</span>
      —
      Category: <a href="/blog/category/modern-opengl/" class="category">Modern OpenGL Series</a>
    </small>
    <div class="main-image">
      <img class="img-responsive" src="/images/posts/modern-opengl-08/main-image.png" />
      
    </div>
  </header>

  <div class="post-content"><p>In this article, we will be adding directional lights, spotlights, and allowing for multiple lights instead of just one. This is the final article on lighting – at least for a while.</p>
<!--more--><p></p><div class="modern-opengl-preamble">
  <h2>Accessing The Code</h2>

  <p>
    Download all the code as a zip from here:
    <a href="https://github.com/tomdalling/opengl-series/archive/master.zip">
      https://github.com/tomdalling/opengl-series/archive/master.zip
    </a>
  </p>

  <p>
    All the code in this series of articles is available from github:
    <a href="https://github.com/tomdalling/opengl-series">https://github.com/tomdalling/opengl-series</a>.
    You can download a zip of all the files from that page, or you can clone the
    repository if you are familiar with git.
  </p>

  <p class="builds-on-previous">
    This article builds on the code from the previous article.
  </p>

  <p>
    The code for this article can be found in the
    <a class="source_folder" href="https://github.com/tomdalling/opengl-series/tree/master/source/08_even_more_lighting">
      <code>source/08_even_more_lighting</code>
    </a>
    folder. On OS X, open the <code>opengl-series.xcodeproj</code> file in the
    root folder, and select the target that corresponds with this article. On
    Windows, open the <code>opengl-series.sln</code> file in Visual Studio 2013,
    and open the project that corresponds with this article.
  </p>

  <p>
    The project includes all of its dependencies, so you shouldn't have to
    install or configure anything extra. Please let me know if you have
    any issues compiling and running the code.
  </p>
</div><h2>Directional Lights</h2><p><figure class="nopadding">  <img src="/images/posts/modern-opengl-08/directional-light.jpg" /> </figure></p><p>Directional lights are lights that shine in a single, uniform direction. That is, all rays of light are parallel to each other. Pure directional lights do not exist (except maybe lasers?) but they are often used in computer graphics to imitate strong light sources that are very far away, such as the Sun. The Sun radiates light in all directions, like a point light. Over an enormous distance, however, the tiny fraction of light rays that make it to earth appear to be almost parallel.</p>
<blockquote class="pull-right">
  Directional lights are implemented such that they ignore attenuation.
</blockquote><p>As we saw in the <a href="/blog/modern-opengl/explaining-homogenous-coordinates-and-projective-geometry/">previous article on homogeneous coordinates</a>, directional lights can be thought of as point lights that are infinitely far away. This causes an unfortunate interaction with attenuation. Attenuation is the reduction of light intensity over distance – the greater the distance, the dimmer the light is. If there is even the tiniest amount of attenuation, over an infinite distance the light becomes infinitely dim (i.e. invisible). For this reason, directional lights are implemented such that they ignore attenuation. This kind-of makes sense if we're using directional lights to represent the Sun, because the sunlight we see here on Earth doesn't appear to be attenuated. That is, sunlight doesn't appear to get dimmer as it gets closer to the ground.</p>
<blockquote class="pull-right">
  We can represent the direction of a directional light with a homogeneous
  coordinate by setting $$W = 0$$.
</blockquote><p>Unlike point lights, directional lights do not need a position coordinate. A directional light only needs a single 3D vector that represents the direction of all the rays of light. However, the GLSL lighting code in our shader expects every light to have a position. Luckily, we can represent the direction of a directional light with a homogeneous coordinate by setting $$W = 0$$. As explained in the <a href="/blog/modern-opengl/explaining-homogenous-coordinates-and-projective-geometry/">previous article on homogeneous coordinates</a>, when $$W = 0$$ in a 4D coordinate, it represents the direction towards a point that is infinitely far away. So if the coordinate represents the direction <em>towards</em> the Sun, we can just negate it to produce the direction <em>away</em> from the Sun, which is the direction of the light rays. Using this method of representing directional lights inside the position vector, we could have code that looks like this:</p>
<div class="highlight"><pre><span class="k">uniform</span> <span class="k">vec4</span> <span class="n">lightPosition</span><span class="p">;</span>

<span class="c1">// check if this is a directional light</span>
<span class="k">if</span><span class="p">(</span><span class="n">lightPosition</span><span class="p">.</span><span class="n">w</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// it is a directional light.</span>
  <span class="c1">// get the direction by converting to vec3 (ignore W) and negate it</span>
  <span class="k">vec3</span> <span class="n">lightDirection</span> <span class="o">=</span> <span class="o">-</span><span class="n">lightPosition</span><span class="p">.</span><span class="n">xyz</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="c1">// NOT a directional light</span>
<span class="p">}</span>
</pre></div><p>As an example, let's say that <code>lightPosition</code> coordinate is $$(1, 0, 0, 0)$$, which represents a point infinitely far away down the <em>positive</em> X axis. If we take the $$X$$, $$Y$$, and $$Z$$ values then negate them, we get $$(-1, 0, 0)$$, which indicates that the light is shining down the <em>negative</em> X axis.</p><p>The GLSL lighting code we implemented in the previous article uses the direction from the surface to the light (in a variable named <code>surfaceToLight</code>), so we don't actually need to negate anything. The GLSL for directional lights in this article looks like this:</p>
<div class="highlight"><pre><span class="k">vec3</span> <span class="n">ApplyLight</span><span class="p">(</span><span class="n">Light</span> <span class="n">light</span><span class="p">,</span> <span class="k">vec3</span> <span class="n">surfaceColor</span><span class="p">,</span> <span class="k">vec3</span> <span class="n">normal</span><span class="p">,</span> <span class="k">vec3</span> <span class="n">surfacePos</span><span class="p">,</span> <span class="k">vec3</span> <span class="n">surfaceToCamera</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">vec3</span> <span class="n">surfaceToLight</span><span class="p">;</span>
    <span class="k">float</span> <span class="n">attenuation</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">w</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//directional light</span>
        <span class="n">surfaceToLight</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
        <span class="n">attenuation</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span> <span class="c1">//no attenuation for directional lights</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// NOT directional light</span>
        <span class="c1">//... (code ommited)</span>
    <span class="p">}</span>

    <span class="c1">// the rest of the lighting calculation</span>
    <span class="c1">//... (code ommited)</span>
<span class="p">}</span>
</pre></div><h2>Spotlights</h2><p><figure class="nopadding">  <img src="/images/posts/modern-opengl-08/spotlight.jpg" /> </figure></p><p>The final type of light we will be implementing is spotlights. Spotlights are very similar to point lights, except that instead of radiating light out in all directions, the light rays are restricted to a cone shape. The light rays are <em>not</em> parallel like directional lights, but they do shine out in a general direction. Think of a flashlight. There is a light bulb in there that acts like a point light, but there is also a reflective curved surface that restricts where the light can shine.</p>
<blockquote class="pull-right">
  We will model spotlights as point lights with a cone restriction.
</blockquote><p>We will model spotlights as point lights with a cone restriction. Everything that applies to point lights also applies to spotlights, except for two extra variables: the direction of the cone, and the angle of the cone. Here is the definition of the <code>Light</code> struct for this article:</p>
<div class="highlight"><pre><span class="k">uniform</span> <span class="k">struct</span> <span class="n">Light</span> <span class="p">{</span>
   <span class="k">vec4</span> <span class="n">position</span><span class="p">;</span>
   <span class="k">vec3</span> <span class="n">intensities</span><span class="p">;</span>
   <span class="k">float</span> <span class="n">attenuation</span><span class="p">;</span>
   <span class="k">float</span> <span class="n">ambientCoefficient</span><span class="p">;</span>
   <span class="k">float</span> <span class="n">coneAngle</span><span class="p">;</span>    <span class="c1">// new</span>
   <span class="k">vec3</span> <span class="n">coneDirection</span><span class="p">;</span> <span class="c1">// new</span>
<span class="p">};</span>
</pre></div><p>There are two new variables that were added in order to implement spotlights: <code>coneAngle</code> and <code>coneDirection</code>. The <code>coneDirection</code> variable is the direction from the point of the cone, through the center of the cone. The <code>coneAngle</code> variable is the angle between the center and the side of the cone, in degrees.</p><p><figure class="black nopadding">  <img src="/images/posts/modern-opengl-08/cone-direction-angle.jpg" /> </figure></p>
<blockquote class="pull-right">
  If the pixel is outside of the cone, then we set the attenuation
  factor to zero.
</blockquote><p>The implementation is fairly simple. For every pixel, we check whether it is inside or outside of the light cone. If it's inside, we continue with the lighting calculations as we normally would. If the pixel is <em>outside</em> of the cone, then we set the attenuation factor to zero, which will make the light ray invisible. Here is the GLSL that implements the cone restriction:</p>
<div class="highlight"><pre><span class="k">float</span> <span class="n">lightToSurfaceAngle</span> <span class="o">=</span> <span class="n">degrees</span><span class="p">(</span><span class="n">acos</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="o">-</span><span class="n">surfaceToLight</span><span class="p">,</span> <span class="n">normalize</span><span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">coneDirection</span><span class="p">))));</span>
<span class="k">if</span><span class="p">(</span><span class="n">lightToSurfaceAngle</span> <span class="o">&gt;</span> <span class="n">light</span><span class="p">.</span><span class="n">coneAngle</span><span class="p">){</span>
    <span class="n">attenuation</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div><p>The first line is pretty dense, so let me explain it by break it down into smaller steps:</p>
<div class="highlight"><pre><span class="c1">// 1. Get the direction for the center of the cone. The `normalize`</span>
<span class="c1">//    function is called just in case `light.coneDirection` isn't</span>
<span class="c1">//    already a unit vector.</span>
<span class="k">vec3</span> <span class="n">coneDirection</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">coneDirection</span><span class="p">);</span>

<span class="c1">// 2. Get the direction of the ray of light. This is the opposite</span>
<span class="c1">//    of the direction from the surface to the light.</span>
<span class="k">vec3</span> <span class="n">rayDirection</span> <span class="o">=</span> <span class="o">-</span><span class="n">surfaceToLight</span><span class="p">;</span>

<span class="c1">// 3. Get the angle between the center of the cone and the ray of light.</span>
<span class="c1">//    The combination of `acos` and `dot` return the angle in radians, then</span>
<span class="c1">//    we convert it to degrees.</span>
<span class="k">float</span> <span class="n">lightToSurfaceAngle</span> <span class="o">=</span> <span class="n">degrees</span><span class="p">(</span><span class="n">acos</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">rayDirection</span><span class="p">,</span> <span class="n">coneDirection</span><span class="p">)))</span>

<span class="c1">// 4. Check if the angle is outside of the cone. If so, set the attenuation</span>
<span class="c1">//    factor to zero, to make the light ray invisible.</span>
<span class="k">if</span><span class="p">(</span><span class="n">lightToSurfaceAngle</span> <span class="o">&gt;</span> <span class="n">light</span><span class="p">.</span><span class="n">coneAngle</span><span class="p">){</span>
  <span class="n">attenuation</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div><p>These cone restrictions are going to be applied to all non-directional lights, which includes point lights. To stop the restrictions from applying to a point light, all we have to do is set <code>coneAngle</code> to <code>180.0</code>, which means that light can shine in all directions.</p><h2>Multiple Lights</h2>
<blockquote class="pull-right">
  We are just refactoring the existing fragment shader code and adding a loop.
</blockquote><p>The fragment shader for the previous article only implemented a single light so let's replace the single light with an array of lights. Then we can loop over them in the fragment shader, and apply them all to the scene. We aren't really implementing anything new here. We are just refactoring the existing fragment shader code and adding a loop.</p><p>The first step is to remove the single light uniform from the fragment shader, and replace it with an array. This is the old GLSL from the previous article:</p>
<div class="highlight"><pre><span class="c1">// code from previous article (a single light)</span>
<span class="k">uniform</span> <span class="k">struct</span> <span class="n">Light</span> <span class="p">{</span>
   <span class="k">vec3</span> <span class="n">position</span><span class="p">;</span>
   <span class="k">vec3</span> <span class="n">intensities</span><span class="p">;</span> <span class="c1">//a.k.a the color of the light</span>
   <span class="k">float</span> <span class="n">attenuation</span><span class="p">;</span>
   <span class="k">float</span> <span class="n">ambientCoefficient</span><span class="p">;</span>
<span class="p">}</span> <span class="n">light</span><span class="p">;</span>
</pre></div><p>And this is the new code, with an array of lights:</p>
<div class="highlight"><pre><span class="c1">// array of lights</span>
<span class="cp">#define MAX_LIGHTS 10</span>
<span class="k">uniform</span> <span class="k">int</span> <span class="n">numLights</span><span class="p">;</span>
<span class="k">uniform</span> <span class="k">struct</span> <span class="n">Light</span> <span class="p">{</span>
   <span class="k">vec4</span> <span class="n">position</span><span class="p">;</span>
   <span class="k">vec3</span> <span class="n">intensities</span><span class="p">;</span> <span class="c1">//a.k.a the color of the light</span>
   <span class="k">float</span> <span class="n">attenuation</span><span class="p">;</span>
   <span class="k">float</span> <span class="n">ambientCoefficient</span><span class="p">;</span>
   <span class="k">float</span> <span class="n">coneAngle</span><span class="p">;</span>
   <span class="k">vec3</span> <span class="n">coneDirection</span><span class="p">;</span>
<span class="p">}</span> <span class="n">allLights</span><span class="p">[</span><span class="n">MAX_LIGHTS</span><span class="p">];</span>
</pre></div><p>This implementation is very similar to the lighting implementation in the old fixed-function pipeline of OpenGL. There is a maximum number of lights, set in the <code>MAX_LIGHTS</code> constant. Then there is an uniform variable that hold the array of lights, called <code>allLights</code>. Lastly, there is a uniform variable that holds the number of lights we are actually using, called <code>numLights</code>.</p><p>The next step is to refactor the GLSL code so that it loops over the array. We extract all the lighting code into a function called <code>ApplyLight</code>, which does the entire lighting calculation for a single light. Here is the GLSL for the <code>ApplyLight</code> function:</p>
<div class="highlight"><pre><span class="k">vec3</span> <span class="n">ApplyLight</span><span class="p">(</span><span class="n">Light</span> <span class="n">light</span><span class="p">,</span> <span class="k">vec3</span> <span class="n">surfaceColor</span><span class="p">,</span> <span class="k">vec3</span> <span class="n">normal</span><span class="p">,</span> <span class="k">vec3</span> <span class="n">surfacePos</span><span class="p">,</span> <span class="k">vec3</span> <span class="n">surfaceToCamera</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">vec3</span> <span class="n">surfaceToLight</span><span class="p">;</span>
    <span class="k">float</span> <span class="n">attenuation</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">w</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//directional light</span>
        <span class="n">surfaceToLight</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">xyz</span><span class="p">);</span>
        <span class="n">attenuation</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span> <span class="c1">//no attenuation for directional lights</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">//point light</span>
        <span class="n">surfaceToLight</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">xyz</span> <span class="o">-</span> <span class="n">surfacePos</span><span class="p">);</span>
        <span class="k">float</span> <span class="n">distanceToLight</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">xyz</span> <span class="o">-</span> <span class="n">surfacePos</span><span class="p">);</span>
        <span class="n">attenuation</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">light</span><span class="p">.</span><span class="n">attenuation</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="n">distanceToLight</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>

        <span class="c1">//cone restrictions (affects attenuation)</span>
        <span class="k">float</span> <span class="n">lightToSurfaceAngle</span> <span class="o">=</span> <span class="n">degrees</span><span class="p">(</span><span class="n">acos</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="o">-</span><span class="n">surfaceToLight</span><span class="p">,</span> <span class="n">normalize</span><span class="p">(</span><span class="n">light</span><span class="p">.</span><span class="n">coneDirection</span><span class="p">))));</span>
        <span class="k">if</span><span class="p">(</span><span class="n">lightToSurfaceAngle</span> <span class="o">&gt;</span> <span class="n">light</span><span class="p">.</span><span class="n">coneAngle</span><span class="p">){</span>
            <span class="n">attenuation</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">//ambient</span>
    <span class="k">vec3</span> <span class="n">ambient</span> <span class="o">=</span> <span class="n">light</span><span class="p">.</span><span class="n">ambientCoefficient</span> <span class="o">*</span> <span class="n">surfaceColor</span><span class="p">.</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">light</span><span class="p">.</span><span class="n">intensities</span><span class="p">;</span>

    <span class="c1">//diffuse</span>
    <span class="k">float</span> <span class="n">diffuseCoefficient</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">surfaceToLight</span><span class="p">));</span>
    <span class="k">vec3</span> <span class="n">diffuse</span> <span class="o">=</span> <span class="n">diffuseCoefficient</span> <span class="o">*</span> <span class="n">surfaceColor</span><span class="p">.</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">light</span><span class="p">.</span><span class="n">intensities</span><span class="p">;</span>
    
    <span class="c1">//specular</span>
    <span class="k">float</span> <span class="n">specularCoefficient</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">diffuseCoefficient</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="n">specularCoefficient</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">surfaceToCamera</span><span class="p">,</span> <span class="n">reflect</span><span class="p">(</span><span class="o">-</span><span class="n">surfaceToLight</span><span class="p">,</span> <span class="n">normal</span><span class="p">))),</span> <span class="n">materialShininess</span><span class="p">);</span>
    <span class="k">vec3</span> <span class="n">specular</span> <span class="o">=</span> <span class="n">specularCoefficient</span> <span class="o">*</span> <span class="n">materialSpecularColor</span> <span class="o">*</span> <span class="n">light</span><span class="p">.</span><span class="n">intensities</span><span class="p">;</span>

    <span class="c1">//linear color (color before gamma correction)</span>
    <span class="k">return</span> <span class="n">ambient</span> <span class="o">+</span> <span class="n">attenuation</span><span class="o">*</span><span class="p">(</span><span class="n">diffuse</span> <span class="o">+</span> <span class="n">specular</span><span class="p">);</span>
<span class="p">}</span>
</pre></div><p>The <code>ApplyLight</code> function takes a single light as an argument, but it also takes some arguments that describe the surface that is being lit: <code>surfaceColor</code>, <code>normal</code>, <code>surfacePos</code>, and <code>surfaceToCamera</code>. Because all the lights are acting upon the same surface, we calculate these surface-related variables once, and pass them in as arguments for every light.</p><p>With all the lighting code extracted into a function, we can loop through all the lights. For each light, we call <code>ApplyLight</code> and add all the results together to get the color for the surface:</p>
<div class="highlight"><pre><span class="k">vec3</span> <span class="n">linearColor</span> <span class="o">=</span> <span class="k">vec3</span><span class="p">(</span><span class="mo">0</span><span class="p">);</span>
<span class="k">for</span><span class="p">(</span><span class="k">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mo">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numLights</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
    <span class="n">linearColor</span> <span class="o">+=</span> <span class="n">ApplyLight</span><span class="p">(</span><span class="n">allLights</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">surfaceColor</span><span class="p">.</span><span class="n">rgb</span><span class="p">,</span> <span class="n">normal</span><span class="p">,</span> <span class="n">surfacePos</span><span class="p">,</span> <span class="n">surfaceToCamera</span><span class="p">);</span>
<span class="p">}</span>
</pre></div><h2>C++ Code Changes</h2><p>The changes to the C++ code are mainly just mirrors of the GLSL changes.</p><p>The <code>Light</code> struct changes slightly, to accommodate directional lights and spotlights. The <code>position</code> element changes from a <code>glm::vec3</code> to a <code>glm::vec4</code>, and we add the two spotlight cone variables <code>coneDirection</code> and <code>coneAngle</code>.</p>
<div class="highlight"><pre><span class="k">struct</span> <span class="n">Light</span> <span class="p">{</span>
    <span class="n">glm</span><span class="o">::</span><span class="n">vec4</span> <span class="n">position</span><span class="p">;</span>
    <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">intensities</span><span class="p">;</span> <span class="c1">//a.k.a. the color of the light</span>
    <span class="kt">float</span> <span class="n">attenuation</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">ambientCoefficient</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">coneAngle</span><span class="p">;</span> <span class="c1">// new</span>
    <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">coneDirection</span><span class="p">;</span> <span class="c1">// new</span>
<span class="p">};</span>
</pre></div><p>In the globals, we change the single light to a <code>std::vector</code> of lights:</p>
<div class="highlight"><pre><span class="c1">// Light gLight; // used to be this in previous article</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Light</span><span class="o">&gt;</span> <span class="n">gLights</span><span class="p">;</span>
</pre></div><p>In the <code>RenderInstance</code> function, we now have to loop through all the lights when we set the uniforms:</p>
<div class="highlight"><pre><span class="n">shaders</span><span class="o">-&gt;</span><span class="n">setUniform</span><span class="p">(</span><span class="s">"numLights"</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">gLights</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

<span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">gLights</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
    <span class="n">SetLightUniform</span><span class="p">(</span><span class="n">shaders</span><span class="p">,</span> <span class="s">"position"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">gLights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">position</span><span class="p">);</span>
    <span class="n">SetLightUniform</span><span class="p">(</span><span class="n">shaders</span><span class="p">,</span> <span class="s">"intensities"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">gLights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">intensities</span><span class="p">);</span>
    <span class="n">SetLightUniform</span><span class="p">(</span><span class="n">shaders</span><span class="p">,</span> <span class="s">"attenuation"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">gLights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">attenuation</span><span class="p">);</span>
    <span class="n">SetLightUniform</span><span class="p">(</span><span class="n">shaders</span><span class="p">,</span> <span class="s">"ambientCoefficient"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">gLights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ambientCoefficient</span><span class="p">);</span>
    <span class="n">SetLightUniform</span><span class="p">(</span><span class="n">shaders</span><span class="p">,</span> <span class="s">"coneAngle"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">gLights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">coneAngle</span><span class="p">);</span>
    <span class="n">SetLightUniform</span><span class="p">(</span><span class="n">shaders</span><span class="p">,</span> <span class="s">"coneDirection"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">gLights</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">coneDirection</span><span class="p">);</span>
<span class="p">}</span>
</pre></div><p>This uses a function called <code>SetLightUniform</code>, which constructs the uniform names based on the struct element and the index (e.g. <code>"allLights[2].coneAngle"</code>).</p>
<div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">SetLightUniform</span><span class="p">(</span><span class="n">tdogl</span><span class="o">::</span><span class="n">Program</span><span class="o">*</span> <span class="n">shaders</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">propertyName</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">lightIndex</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span> <span class="n">ss</span><span class="p">;</span>
    <span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="s">"allLights["</span> <span class="o">&lt;&lt;</span> <span class="n">lightIndex</span> <span class="o">&lt;&lt;</span> <span class="s">"]."</span> <span class="o">&lt;&lt;</span> <span class="n">propertyName</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">uniformName</span> <span class="o">=</span> <span class="n">ss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>

    <span class="n">shaders</span><span class="o">-&gt;</span><span class="n">setUniform</span><span class="p">(</span><span class="n">uniformName</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
</pre></div><p>In <code>AppMain</code>, we create a spotlight and a directional light:</p>
<div class="highlight"><pre><span class="c1">// setup lights</span>
<span class="n">Light</span> <span class="n">spotlight</span><span class="p">;</span>
<span class="n">spotlight</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec4</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="n">spotlight</span><span class="p">.</span><span class="n">intensities</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span> <span class="c1">//strong white light</span>
<span class="n">spotlight</span><span class="p">.</span><span class="n">attenuation</span> <span class="o">=</span> <span class="mf">0.1f</span><span class="p">;</span>
<span class="n">spotlight</span><span class="p">.</span><span class="n">ambientCoefficient</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span> <span class="c1">//no ambient light</span>
<span class="n">spotlight</span><span class="p">.</span><span class="n">coneAngle</span> <span class="o">=</span> <span class="mf">15.0f</span><span class="p">;</span>
<span class="n">spotlight</span><span class="p">.</span><span class="n">coneDirection</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

<span class="n">Light</span> <span class="n">directionalLight</span><span class="p">;</span>
<span class="n">directionalLight</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec4</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">//w == 0 indications a directional light</span>
<span class="n">directionalLight</span><span class="p">.</span><span class="n">intensities</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">0.3</span><span class="p">,</span><span class="mf">0.1</span><span class="p">);</span> <span class="c1">//weak yellowish light</span>
<span class="n">directionalLight</span><span class="p">.</span><span class="n">ambientCoefficient</span> <span class="o">=</span> <span class="mf">0.06</span><span class="p">;</span>

<span class="n">gLights</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">spotlight</span><span class="p">);</span>
<span class="n">gLights</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">directionalLight</span><span class="p">);</span>
</pre></div><p>And in the <code>Update</code> function, we make the key <kbd>1</kbd> change the position and direction of the spotlight:</p>
<div class="highlight"><pre><span class="c1">//move light</span>
<span class="k">if</span><span class="p">(</span><span class="n">glfwGetKey</span><span class="p">(</span><span class="sc">'1'</span><span class="p">)){</span>
    <span class="n">gLights</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">position</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">vec4</span><span class="p">(</span><span class="n">gCamera</span><span class="p">.</span><span class="n">position</span><span class="p">(),</span> <span class="mf">1.0</span><span class="p">);</span>
    <span class="n">gLights</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">coneDirection</span> <span class="o">=</span> <span class="n">gCamera</span><span class="p">.</span><span class="n">forward</span><span class="p">();</span>
<span class="p">}</span>
</pre></div><h2>Further Lighting</h2><p>At this point, we have basically implemented all the lighting options that were available in the old fixed-function API of OpenGL. We went a step further by implementing per-fragment lighting instead of per-vertex lighting, but there are many more improvements that we haven't covered. Lighting is a huge subject, so for now I'm just going to give a brief overview of a few advanced lighting topics.</p><h3>Blinn-Phong</h3><p>Our lighting in this series is an implemention of the Phong reflection model. There is a slightly better version of this algorithm, called the <a href="http://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model">Blinn-Phong</a> reflection model. Blinn-Phong is a bit more accurate, and has slightly better performance too.</p><h3>Fancier Spotlights</h3><p>The spotlight implementation in this article is very basic. It could be improved by softening the hard edges in GLSL using the <a href="https://www.opengl.org/sdk/docs/man/html/mix.xhtml">mix function</a>. You could also sample a flashlight texture to stop the light from looking so circular and flat.</p><h3>Deferred Rendering</h3><p><figure class="youtube">  <iframe src="//www.youtube.com/embed/vooznqE-XMM" frameborder="0" allowfullscreen="allowfullscreen"></iframe> </figure></p><p>The way we have implemented lighting is known as <em>forward rendering</em>, and there are a couple of annoying issues associated with it. Firstly, there is a limit to the number of lights we can have. Secondly, every pixel that gets drawn requires calculations for every light – even if there are lights that do not affect the pixel – which can be a performance issue. Ideally, we want to be able to have thousands of lights with decent performance. To address these issues, we could use <a href="http://gamedev.stackexchange.com/questions/74/what-is-deferred-rendering">deferred rendering</a>.</p><p>Deferred rendering is a technique where you split rendering up into multiple passes. The first pass renders geometry without any lights. In subsequent passes, the lights are rendered one at a time. Lighting happens to every <em>pixel</em>, instead of every <em>fragment</em>, which improves performance. You are also able to restrict which pixels each light affects to further improve performance.</p><p>In summary, deferred rendering allows lots of lights with decent performance, but it is more complicated than forward rendering.</p><h3>Shadows</h3><p><figure class="youtube">  <iframe src="//www.youtube.com/embed/0EjvtQdTHB0" frameborder="0" allowfullscreen="allowfullscreen"></iframe> </figure></p><p>Despite that fact that everyone loves the look of them, nice shadows are a huge can of worms, and can be extremely complicated. All the following techniques are way more complicated than what this series of articles has covered so far.</p><p><a href="http://codeflow.org/entries/2013/feb/15/soft-shadow-mapping/">Shadow maps</a> are probably the simplest technique, but the resulting shadows can be weird and pixelated.</p><p><a href="http://http.developer.nvidia.com/GPUGems3/gpugems3_ch11.html">Shadow volumes</a> give pixel-perfect results, but they require complicated processing on your geometry, which is slow.</p><p>When the light and the geometry are both static, then <a href="http://en.wikipedia.org/wiki/Lightmap">lightmaps</a> are accurate and have good performance.</p><p>Don't even get me started on <a href="http://gamedev.stackexchange.com/questions/23/what-is-ambient-occlusion">ambient occlusion</a>.</p><h3>High-dynamic-range (HDR)</h3><p><figure class="nopadding">  <img class="captioned" src="/images/posts/modern-opengl-08/hdr.jpg" />  <figcaption>  Image courtesy of  <a href="http://commons.wikimedia.org/wiki/File:Slowenien,_Portorose_(HDR-Aufnahme_vs_Normalbelichtung).jpg">  Richard Huber  </a>  </figcaption> </figure></p><p>Notice how the colors from all the lights are added together in our fragment shader. The RGBA values are supposed to be within the 0.0 to 1.0 range, so what happens if there are lots of lights, and the sum ends up being greater than 1.0? The colors would get clamped, and look weird. Also, if the lights are too dim, the whole scene could look basically black, with no detail. High-dynamic-range (HDR) rendering can help to fix these problems.</p><p>The human eye adjusts depending on the brightness of what it's looking at. If you are in a dark room for long enough, your pupils dilate to allow more light to reach your retina, which makes the room seem brighter. If you walk outside into bright sunlight, the opposite happens, so that you don't go blind from the intense light. HDR rendering sort of imitates how your eye works, in order to keep the details visible in very dark and very bright scenes. RGB values are allowed to go above 1.0 during lighting calculations, then the values are later rescaled so that they fit nicely within the 0.0–1.0 range.</p><h3>Subsurface Scattering</h3><p><figure class="black">  <img src="/images/posts/modern-opengl-08/sss.png" />  <figcaption>  Image courtesy of  <a href="http://commons.wikimedia.org/wiki/File:Subsurface_scattering.png">  Piotrek Chwała  </a>  </figcaption> </figure></p><p>Light doesn't just reflect <em>off</em> of surfaces, it can travel <em>through</em> them too. When light penetrates a surface, it changes the color of that surface. Rendering this color change is called <a href="http://www.iryoku.com/screen-space-subsurface-scattering">subsurface scattering</a>.</p><p>Even though skin looks fairly opaque, subsurface scattering is generally used for realistic rendering of human skin. Without it, skin tends to look like painted plastic.</p><h3>Emissive Surfaces</h3><p><figure class="nopadding">  <img class="captioned" src="/images/posts/modern-opengl-08/emissive.png" />  <figcaption>Emissive surfaces from the game Borderlands</figcaption> </figure></p><p>In our implementation, only lights can illuminate a surface. Some surfaces, however, provide their own illumination, which makes it look like they are glowing. Think of a firefly, glow-in-the-dark stickers, or <a href="http://en.wikipedia.org/wiki/List_of_bioluminescent_fungi">those weird glowing mushrooms</a>.</p><p>Emissive lights are pretty easy to implement in OpenGL. Send an extra color uniform to the shaders, along with the materials texture and shininess, and add that color to the final color. Alternatively, you can send an extra texture instead of a single color.</p><h3>Normal Mapping</h3><p><figure>  <img src="/images/posts/modern-opengl-08/normal-map.png" />  <figcaption>  Image courtesy of  <a href="http://commons.wikimedia.org/wiki/File:Normal_map_example.png">  Paolo Cignoni  </a>  </figcaption> </figure></p><p>3D meshes have limits to the number of vertices they can contain, due to performance. Making a surface rough or bumpy with geometry can take a lot of vertices, so <a href="http://en.wikipedia.org/wiki/Normal_mapping">normal maps</a> are often used instead. Normal maps can be used to make an angular-looking 3D model look less angular, and more realistic.</p><p>A normal map is a texture that affects the surface normal. It is like the surface texture that we have implemented, except it contains XYZ vectors instead of RGB colors. The surface normal is an important part of the lighting calculations, and it affects the brightness of each pixel.</p><h2>Conclusion</h2><p>That wraps up our lighting implementation for now. After adding directional lights and spotlights, we have recreated the functionality that was available in the old fixed-function OpenGL API.</p></div>

  <footer>
    <div class="alert alert-info subscribe-bait">
      <p><strong>Enjoy this post?</strong></p>
      <a class="btn btn-success" href="/feed/">
        Subscribe via RSS
      </a>
      <a data-size="large" data-show-count="false" class="twitter-follow-button" href="https://twitter.com/tom_dalling">Follow @tom_dalling</a>
      <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
    </div>

    <h2>Comments</h2>
    <div id="disqus_thread"></div>
    <script id="disqus_script" type="text/javascript">
      var disqus_shortname = "tomdalling";
      var disqus_identifier = "com.tomdalling.modern-opengl-series.08";
      var disqus_title = "Modern OpenGL 08 \u2013 Even More Lighting: Directional Lights, Spotlights, & Multiple Lights";
      var disqus_url = "http:\/\/www.tomdalling.com\/blog\/modern-opengl\/08-even-more-lighting-directional-lights-spotlights-multiple-lights\/";

      (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments.</a></noscript>
  </footer>

</article></main>

        <div class="col-md-4 sidebar">

          <div class="panel panel-default">
            <div class="panel-heading">Subscribe</div>
            <ul class="list-group">
              <li class="list-group-item">
                <a href="/blog/feed/">
                  <i class="fa fa-rss"></i> RSS
                </a>
              </li>
              <li class="list-group-item">
                <a href="https://twitter.com/tom_dalling">
                  <i class="fa fa-twitter"></i> Twitter
                </a>
              </li>
            </ul>
          </div>

          <div class="panel panel-default">
            <div class="panel-heading">Recent Posts</div>
            <ul class="list-group recent-posts">
              <li class="list-group-item">
                <a href="/blog/ruby/pure-function-as-an-object-PFAAO-pattern/">The Pure Function As An Object (PFAAO) Ruby Pattern</a>
              </li><li class="list-group-item">
                <a href="/blog/software-design/fizzbuzz-in-too-much-detail/">FizzBuzz In Too Much Detail</a>
              </li><li class="list-group-item">
                <a href="/blog/ruby/fruity-bat-flappy-bird-clone-in-ruby/">Making Fruity Bat (a Flappy Bird clone) in Ruby</a>
              </li><li class="list-group-item">
                <a href="/blog/modern-opengl/08-even-more-lighting-directional-lights-spotlights-multiple-lights/">Modern OpenGL 08 – Even More Lighting: Directional Lights, Spotlights, &amp; Multiple Lights</a>
              </li><li class="list-group-item">
                <a href="/blog/modern-opengl/opengl-in-2014/">OpenGL in 2014</a>
              </li>
            </ul>
          </div>

          <div class="panel panel-default">
            <div class="panel-heading">Blog Categories</div>
            <ul class="list-group categories">
              <li class="list-group-item">
                <a class="category" href="/blog/category/cocoa/">Cocoa</a>
                (<span class="post-count">5</span>
                <a href="/blog/category/cocoa/feed/" class="feed"><i class="fa fa-rss"></i></a>)
              </li><li class="list-group-item">
                <a class="category" href="/blog/category/coding-styleconventions/">Coding Style/Conventions</a>
                (<span class="post-count">3</span>
                <a href="/blog/category/coding-styleconventions/feed/" class="feed"><i class="fa fa-rss"></i></a>)
              </li><li class="list-group-item">
                <a class="category" href="/blog/category/coding-tips/">Coding Tips</a>
                (<span class="post-count">4</span>
                <a href="/blog/category/coding-tips/feed/" class="feed"><i class="fa fa-rss"></i></a>)
              </li><li class="list-group-item">
                <a class="category" href="/blog/category/random-stuff/">Miscellaneous</a>
                (<span class="post-count">1</span>
                <a href="/blog/category/random-stuff/feed/" class="feed"><i class="fa fa-rss"></i></a>)
              </li><li class="list-group-item">
                <a class="category" href="/blog/category/modern-opengl/">Modern OpenGL Series</a>
                (<span class="post-count">10</span>
                <a href="/blog/category/modern-opengl/feed/" class="feed"><i class="fa fa-rss"></i></a>)
              </li><li class="list-group-item">
                <a class="category" href="/blog/category/ruby/">Ruby</a>
                (<span class="post-count">2</span>
                <a href="/blog/category/ruby/feed/" class="feed"><i class="fa fa-rss"></i></a>)
              </li><li class="list-group-item">
                <a class="category" href="/blog/category/software-design/">Software Design</a>
                (<span class="post-count">9</span>
                <a href="/blog/category/software-design/feed/" class="feed"><i class="fa fa-rss"></i></a>)
              </li><li class="list-group-item">
                <a class="category" href="/blog/category/software-processes/">Software Processes</a>
                (<span class="post-count">1</span>
                <a href="/blog/category/software-processes/feed/" class="feed"><i class="fa fa-rss"></i></a>)
              </li><li class="list-group-item">
                <a class="category" href="/blog/category/web/">Web</a>
                (<span class="post-count">1</span>
                <a href="/blog/category/web/feed/" class="feed"><i class="fa fa-rss"></i></a>)
              </li>
            </ul>
          </div>

          <div class="panel panel-default">
            <div class="panel-heading">Blog Archives</div>
            <ul class="list-group archives">
              <li class="list-group-item">
                <a class="month" href="/blog/2016/02/">February 2016</a>
                (<span class="post-count">1</span>)
              </li><li class="list-group-item">
                <a class="month" href="/blog/2015/04/">April 2015</a>
                (<span class="post-count">1</span>)
              </li><li class="list-group-item">
                <a class="month" href="/blog/2015/02/">February 2015</a>
                (<span class="post-count">1</span>)
              </li><li class="list-group-item">
                <a class="month" href="/blog/2014/11/">November 2014</a>
                (<span class="post-count">1</span>)
              </li><li class="list-group-item">
                <a class="month" href="/blog/2014/09/">September 2014</a>
                (<span class="post-count">1</span>)
              </li><li class="list-group-item">
                <a class="month" href="/blog/2014/02/">February 2014</a>
                (<span class="post-count">1</span>)
              </li><li class="list-group-item">
                <a class="month" href="/blog/2013/04/">April 2013</a>
                (<span class="post-count">1</span>)
              </li><li class="list-group-item">
                <a class="month" href="/blog/2013/03/">March 2013</a>
                (<span class="post-count">1</span>)
              </li><li class="list-group-item">
                <a class="month" href="/blog/2013/02/">February 2013</a>
                (<span class="post-count">1</span>)
              </li><li class="list-group-item">
                <a class="month" href="/blog/2013/01/">January 2013</a>
                (<span class="post-count">2</span>)
              </li><li class="list-group-item">
                <a class="month" href="/blog/2012/12/">December 2012</a>
                (<span class="post-count">2</span>)
              </li><li class="list-group-item">
                <a class="month" href="/blog/2012/11/">November 2012</a>
                (<span class="post-count">2</span>)
              </li><li class="list-group-item">
                <a class="month" href="/blog/2012/07/">July 2012</a>
                (<span class="post-count">2</span>)
              </li><li class="list-group-item">
                <a class="month" href="/blog/2012/05/">May 2012</a>
                (<span class="post-count">2</span>)
              </li><li class="list-group-item">
                <a class="month" href="/blog/2012/03/">March 2012</a>
                (<span class="post-count">2</span>)
              </li><li class="list-group-item">
                <a class="month" href="/blog/2011/12/">December 2011</a>
                (<span class="post-count">1</span>)
              </li><li class="list-group-item">
                <a class="month" href="/blog/2010/12/">December 2010</a>
                (<span class="post-count">1</span>)
              </li><li class="list-group-item">
                <a class="month" href="/blog/2010/11/">November 2010</a>
                (<span class="post-count">1</span>)
              </li><li class="list-group-item">
                <a class="month" href="/blog/2010/05/">May 2010</a>
                (<span class="post-count">1</span>)
              </li><li class="list-group-item">
                <a class="month" href="/blog/2010/04/">April 2010</a>
                (<span class="post-count">1</span>)
              </li><li class="list-group-item">
                <a class="month" href="/blog/2010/02/">February 2010</a>
                (<span class="post-count">1</span>)
              </li><li class="list-group-item">
                <a class="month" href="/blog/2009/12/">December 2009</a>
                (<span class="post-count">1</span>)
              </li><li class="list-group-item">
                <a class="month" href="/blog/2009/11/">November 2009</a>
                (<span class="post-count">3</span>)
              </li><li class="list-group-item">
                <a class="month" href="/blog/2009/10/">October 2009</a>
                (<span class="post-count">2</span>)
              </li><li class="list-group-item">
                <a class="month" href="/blog/2009/07/">July 2009</a>
                (<span class="post-count">1</span>)
              </li><li class="list-group-item">
                <a class="month" href="/blog/2009/06/">June 2009</a>
                (<span class="post-count">1</span>)
              </li><li class="list-group-item">
                <a class="month" href="/blog/2009/05/">May 2009</a>
                (<span class="post-count">1</span>)
              </li>
            </ul>
          </div>

        </div>
      </div>

      <footer class="page-footer">
        <p>© 2009 – <span class="current-year">2016</span> Tom Dalling</p>

        <p class="social">
          <a href="https://twitter.com/tom_dalling">
            <i class="fa fa-lg fa-twitter"></i>
          </a>
          <a href="https://github.com/tomdalling">
            <i class="fa fa-lg fa-github"></i>
          </a>
          <a href="https://stackoverflow.com/users/108105/tom-dalling">
            <i class="fa fa-lg fa-stack-overflow"></i>
          </a>
          <a href="mailto:tom at tomdalling com">
            <i class="fa fa-lg fa-envelope"></i>
          </a>
        </p>
      </footer>

      <script src="/bundles/all.js"></script>
      <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {
            inlineMath: [['$$','$$']],
            displayMath: [['[blockmath]', '[/blockmath]']]
          }
        });
      </script>
      <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </div></body>

</html>